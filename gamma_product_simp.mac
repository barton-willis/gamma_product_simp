/* Author: Barton Willis, copyright 2022

Maxima code for simplifying expressions that involve products of
gamma functions.

This is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License GPLv3; see
https://www.gnu.org/licenses/quick-guide-gplv3.html .
*/
 
 /* The CL translator suggests adding the following. */
 eval_when(translate,declare_translated(gamma_arg_increase,gamma_arg_decrease,
         gamma_product_simp))$

 load("opsubst");
 load("op_predicates");

 /* Return a lambda form that generates the Gauss gamma function 
 product identity; see http://dlmf.nist.gov/5.5.E6 */
 make_gamma_product_id() := buildq([x : gensym(), k : gensym(),n : gensym()],
    lambda([x,n], prod(gamma(x+k/n),k,0,n-1) = gamma(n*x)/((2*%pi)^((1-n)/2)*n^(n*x-1/2))));


/* Apply ratsimp only to the arguments of gamma. */
ratsimp_gamma_args(e) := block([inflag : true],
  if mapatom(e) then e
  elseif inpart(e,0) = 'gamma then gamma(ratsimp(first(e)))
  else map('ratsimp_gamma_args, e));

 /* This is the user level function. Actually, it's the only function
 in this file that is intended to be a user level function.*/

gamma_simp(e) := block([opsubst : true],
  e : ratsimp_gamma_args(makegamma(e)), /* not sure I like this */
  e : homogenize_gamma(e),
  e : gamma_arg_increase(gamma_arg_decrease(e)),
  subst("*" = lambda([[q]], gamma_product_simp(xreduce("*",q))),e));

 gamma_product_simp(e) := block([a,N,id,ee,dn,fn,keepfloat : true],
    ee : e,    
    a : map('first, gatherargs(e,'gamma)),
    N : length(a),

   /* Do gamma(X) gamma(n-X) ==> pochhammer(1-X,n-1) %pi/sin(%pi X), when
       n is explicitly a nonnegative integer. */
    for ak in a do (
        for bk in a do (
        dn : ak+bk,
        if integerp(dn) and dn >= 0 and (not featurep(ak,'integer)) then (
            e : ratsubst(pochhammer(1-ak, dn-1) *%pi/sin(%pi*ak),
                gamma(ak)*gamma(bk),e)))),

    /* Do prod(gamma(x+k/n),k,0,n-1) ==> gamma(n*x)/((2*%pi)^((1-n)/2)*n^(n*x-1/2))
    */
    fn : make_gamma_product_id(),
    for ak in a do (
       for n : 2 thru N do (
          id : ratsimp(fn(ak,n)),
          e : ratsubst(rhs(id), lhs(id), e))),
    /* When the expression has changed, recurse; otherwise return e.*/       
    if is(e # ee) then gamma_product_simp(e) else e)$

/* When n is a positive integer and the expression e involves both
   gamma(X+n) and gamma(X), do gamma(X+n) ==> pochhammer(X,n) gamma(X).
   The expansion of the pochhammer term is controlled by the option variable
   pochhammer_max_index (default 100). If the expression e changes after finishing
   the double loop, recurse.

   Each time a match to gamma(X+n) & gamma(X) is detected, dispatch facsum on the
   result. */

homogenize_gamma(e) := block([a,ee : e],
   a : map('first, gatherargs(e,'gamma)),
   for ak in a do (
      for bk in a do (
         if featurep(ak-bk,'integer) and ak-bk > 0 then (
            e : ratsubst(pochhammer(bk,ak-bk)*gamma(bk), gamma(ak),e),
            e : facsum(e,gamma(bk))))),
      if is(e # ee) then homogenize_gamma(e) else e)$ 



/* Do X*gamma(X) ==> gamma(X+1). Repeat until there are no more such terms. 
   See http://dlmf.nist.gov/5.5.E1 */

gamma_arg_increase(e) := block([a,ee : e],
  if mapatom(e) then e
  elseif mtimesp(e) then (
     a : map('first, gatherargs(e,'gamma)),
     for ak in a do (
        if member(ak,e) then (
            e : ratsubst(gamma(ak+1), ak*gamma(ak),e))),            
      if is(e # ee) then gamma_arg_increase(e) else e)
  else map('gamma_arg_increase, e)); 

/* Do gamma(X+1)/X ==> gamma(X). Repeat until there are no more
   such terms. This misses cases such as:

       gamma_arg_decrease(gamma(x+1/2)/((2*x+1)/2))  
       
   I should fix that.*/

gamma_arg_decrease(e) := block([a, ee : e],
  if mapatom(e) then e
  elseif mtimesp(e) then (
     a : map('first, gatherargs(e,'gamma)),
     for ak in a do (
        if member(1/(ak-1),e) then (
            e : ratsubst(gamma(ak-1), gamma(ak)/(ak-1),e))), 
      if is(e # ee) then gamma_arg_decrease(e) else e)
  else map('gamma_arg_decrease, e));   


              
